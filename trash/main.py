#в файле fiweWays я бы мог сделать более оптимизированный код, потому что в первых 2 случаях сортировка почти идентична, и в трех остальных соответственно, т.е вынести код  для каждого случая в отдельную функцию, но понял это уже после, лень переделвать

import tableOutput
import chooseOne
import chooseTwo
import functionTwo
import glob, os #поиск ФАЙЛА АВТОМАТИЧЕСКИ

print("это уже я доделываю финальный штрих проги, решил сделать ее более адаптивной, например на несколько сотен студентов, а не на 39 человек.\n а еще при внесении новых гендеров (как это сейчас модно) или факультетов, она их обработает. \n  ввежите колличество студентов , занесенных в таблицу (если вы запишите больше или меньше, не критичною но рекомендуется ввести 39 т.к в таблице 39 студентов)")
countStudents = 0
correct0 = 0
while correct0 == 0:
    countStudents = int(input())
    if countStudents > 0:
        correct0 = 1
    else:
        print("я вам запрещаю вводить отрицательное или равное нулю число")   #эти 9 строчек не очень хорошо что размещены тут, но хочу сегодня отправить, а создавать отдельный класс сегодня поздно

print("ВНИМАНИЕ \n программа предазначена для работы с файлами в текущей дериктории. ПРи попытке обращения к таблице, находящейся в другой папке, программа не сможет ее обнаружить")
mainFolder = os.getcwd()

nameFile, book = chooseOne.example3.choose1(mainFolder)

countOfStudents = tableOutput.example.readTable(book, countStudents)
print(f"был открыт файл \n {nameFile}")
correct3 = 0
while correct3 == 0:
    way2 = chooseTwo.example4.choose2()
    if way2 == "6":# вариант выхода из программы
        #break
        correct3 = 1
        continue #мы прерываем неполный цикл, и при этом у нас не выыполняется условие, и программа завершается. не очень корректно, т.к есть break, но я художник
    functionTwo.example2.erer(way2, book, countStudents)